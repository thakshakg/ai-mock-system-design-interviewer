<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI System Design Mock Interviewer</title>
    <script src="https://js.puter.com/v2/"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/split.js/1.6.2/split.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsplumb@2.15.6/dist/js/jsplumb.min.js"></script>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                Helvetica, Arial, sans-serif;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        h1 {
            color: #FFD700;
            text-align: center;
            margin-top: 0;
        }

        #main-container {
            display: flex;
            flex-grow: 1;
            gap: 0;
            /* Remove gap, gutter will handle spacing */
            min-height: 0;
            width: 100%;
            height: calc(100% - 80px);
            /* Adjust height for the title */
        }

        #whiteboard-area {
            /* flex: 3; */
            /* Split.js will handle the width */
            border: 1px solid #555;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            padding: 15px;
            overflow: hidden;
        }

        #chat-area {
            /* flex: 1; */
            /* Split.js will handle the width */
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow: hidden;
            padding: 0 15px;
            box-sizing: border-box;
        }

        .gutter {
            background-color: #333;
            background-repeat: no-repeat;
            background-position: 50%;
        }

        .gutter.gutter-horizontal {
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bM/5+BgeE4ARCMGkvGEgZgSpcRzQEAUg4fV4sO4sAAAAAASUVORK5CYII=');
            cursor: col-resize;
        }

        .group-wrapper {
            padding: 15px;
            border: 1px solid #555;
            border-radius: 5px;
            background-color: #222;
        }

        #components-palette {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #555;
            border-radius: 5px;
            background-color: #2a2a2a;
        }

        .component-btn {
            padding: 8px 12px;
            border-radius: 3px;
            border: 1px solid #555;
            background-color: #333;
            color: #f0f0f0;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        .component-btn:hover {
            background-color: #444;
        }

        .design-component {
            position: absolute;
            border: 2px solid #4CAF50;
            border-radius: 5px;
            background-color: rgba(76, 175, 80, 0.1);
            padding: 8px;
            color: #f0f0f0;
            font-size: 12px;
            text-align: center;
            min-width: 80px;
            min-height: 40px;
            cursor: move;
            z-index: 1000;
        }

        .client-component {
            border-color: #2196F3;
            background-color: rgba(33, 150, 243, 0.1);
        }

        .server-component {
            border-color: #FF9800;
            background-color: rgba(255, 152, 0, 0.1);
        }

        .database-component {
            border-color: #9C27B0;
            background-color: rgba(156, 39, 176, 0.1);
        }

        .cache-component {
            border-color: #F44336;
            background-color: rgba(244, 67, 54, 0.1);
        }

        .gateway-component {
            border-color: #607D8B;
            background-color: rgba(96, 125, 139, 0.1);
        }

        .queue-component {
            border-color: #795548;
            background-color: rgba(121, 85, 72, 0.1);
        }

        .balancer-component {
            border-color: #009688;
            background-color: rgba(0, 150, 136, 0.1);
        }

        .cdn-component {
            border-color: #CDDC39;
            background-color: rgba(205, 220, 57, 0.1);
        }

        .ai-component {
            border-color: #E91E63;
            background-color: rgba(233, 30, 99, 0.1);
        }

        .storage-component {
            border-color: #3F51B5;
            background-color: rgba(63, 81, 181, 0.1);
        }

        .custom-component {
            border-color: #8BC34A;
            background-color: rgba(139, 195, 74, 0.1);
        }

        .connection-context-menu {
            position: fixed;
            background: #333;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 5px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            z-index: 10000;
            min-width: 150px;
            display: none;
        }

        .connection-help {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #f0f0f0;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 11px;
            z-index: 1000;
            display: none;
        }

        .connection-help.show {
            display: block;
        }

        .context-menu-item {
            padding: 8px 15px;
            color: #f0f0f0;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        .context-menu-item:hover {
            background-color: #444;
        }

        .context-menu-item.active {
            background-color: #FFD700;
            color: #000;
        }

        .context-menu-divider {
            height: 1px;
            background-color: #555;
            margin: 4px 0;
        }

        .context-menu-text-section {
            padding: 8px 12px;
            background-color: #2a2a2a;
            border-top: 1px solid #555;
            border-bottom: 1px solid #555;
        }

        .context-menu-text-section label {
            display: block;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 4px;
            color: #f0f0f0;
        }

        #connection-text-input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #555;
            border-radius: 3px;
            font-size: 11px;
            margin-bottom: 6px;
            box-sizing: border-box;
            background-color: #333;
            color: #f0f0f0;
        }

        #connection-text-input:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.25);
        }

        .text-update-btn {
            background-color: #FFD700;
            color: #000;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            width: 100%;
            font-weight: bold;
        }

        .text-update-btn:hover {
            background-color: #FFC107;
        }

        .connection-label {
            background-color: rgba(255, 215, 0, 0.9);
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            border: 1px solid #FFD700;
            cursor: pointer;
            max-width: 100px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .connection-label:hover {
            background-color: #FFD700;
            transform: scale(1.05);
        }

        .canvas-container {
            flex-grow: 1;
            position: relative;
        }

        #whiteboard-canvas {
            border: 1px solid #444;
            border-radius: 5px;
            position: absolute;
            top: 0;
            left: 0;
            display: none;
        }

        #chat-container {
            border: 1px solid #444;
            border-radius: 5px;
            padding: 20px;
            overflow-y: scroll;
            background-color: #222;
            flex-grow: 1;
            min-height: 0;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 5px;
        }

        .user-message {
            text-align: right;
            background-color: #333;
        }

        .ai-message {
            text-align: left;
            background-color: #2a2a2a;
        }

        #input-container {
            display: flex;
            flex-direction: column;
            margin-top: 20px;
        }

        #user-input {
            flex-grow: 1;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: #f0f0f0;
            width: 100%;
            box-sizing: border-box;
        }

        .action-button {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            background-color: #FFD700;
            color: black;
            cursor: pointer;
            font-size: 16px;
        }

        #send-btn {
            margin-top: 10px;
            width: 100px;
            align-self: flex-end;
        }

        #send-btn:disabled {
            background-color: #444;
            color: #888;
            cursor: not-allowed;
        }

        .group-wrapper {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #555;
            border-radius: 5px;
        }

        label {
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <h1>AI System Design Mock Interviewer</h1>

    <div id="main-container">
        <div id="whiteboard-area">
            <div id="components-palette">
                <div class="component-btn" data-component="client">üì± Client</div>
                <div class="component-btn" data-component="server">üñ•Ô∏è Server</div>
                <div class="component-btn" data-component="database">üóÉÔ∏è Database</div>
                <div class="component-btn" data-component="cache">‚ö° Cache</div>
                <div class="component-btn" data-component="gateway">üö™ API Gateway</div>
                <div class="component-btn" data-component="queue">üì¨ Queue</div>
                <div class="component-btn" data-component="balancer">‚öñÔ∏è Load Balancer</div>
                <div class="component-btn" data-component="cdn">üåê CDN</div>
                <div class="component-btn" data-component="ai">ü§ñ AI</div>
                <div class="component-btn" data-component="storage">üíæ Storage</div>
                <div class="component-btn" data-component="custom">üîß Custom</div>
            </div>
            <div class="canvas-container">
                <canvas id="whiteboard-canvas" style="display: none;"></canvas>
                <div id="jsplumb-container"
                    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;"></div>
                <div id="connection-context-menu" class="connection-context-menu">
                    <div class="context-menu-item" data-arrow-type="one-way">
                        ‚û°Ô∏è One-way Arrow
                    </div>
                    <div class="context-menu-item" data-arrow-type="double">
                        ‚ÜîÔ∏è Double Arrow
                    </div>
                    <div class="context-menu-item" data-arrow-type="none">
                        ‚ûñ No Arrow
                    </div>
                    <div class="context-menu-divider"></div>
                    <div class="context-menu-text-section">
                        <label for="connection-text-input">üìù Label:</label>
                        <input type="text" id="connection-text-input" placeholder="Enter text..." maxlength="50">
                        <button id="update-text-btn" class="text-update-btn">Update</button>
                    </div>
                    <div class="context-menu-divider"></div>
                    <div class="context-menu-item" data-action="delete">
                        üóëÔ∏è Delete Connection
                    </div>
                </div>
                <div id="connection-help" class="connection-help">
                    üí° Tip: Double-click connections to customize arrow types and add labels
                </div>
            </div>
        </div>

        <div id="chat-area">
            <div class="group-wrapper">
                <label for="question-select">Select a System Design Question:</label>
                <select id="question-select"></select>
            </div>

            <div id="chat-container"></div>

            <div id="input-container">
                <textarea id="user-input" placeholder="Type your response here..."></textarea>
                <button id="send-btn" class="action-button">Send</button>
            </div>
        </div>
    </div>

    <script>
        // --- Agent Definitions ---
        const interviewerAgent = {
            getPrompt(stage, question = '', history = [], state = {}) {
                const basePrompt = `You are a system design mock interviewer, a seasoned and knowledgeable expert in software architecture. Your primary goal is to simulate a realistic system design interview for a candidate.

**Personality:** You are patient, supportive, and articulate, but also challenging. You'll act as a peer, not just an interrogator. Your tone should be encouraging, focusing on guiding the candidate toward a good solution rather than simply catching them in a mistake. Use clarifying questions to probe deeper into their reasoning.

**Meta-Instructions:**
- You must wait for the candidate's response at each stage. Do not rush them.
- Your primary objective is to evaluate their thought process, not just their final answer.
- Maintain a conversational and encouraging tone throughout the interview.`;

                const stagePrompts = {
                    'clarification': `
**Current Stage: Requirements Clarification**
**Your Persona:** The "Helpful Colleague."
**Your Objective:** To guide the user in clarifying functional and non-functional requirements for the following problem: "${question}".
**Your Task:** Ask questions about features, user scale, latency, availability, security, and other critical constraints. Evaluate the user's ability to ask clarifying questions and their understanding of the problem's scope.
Start the conversation with a friendly greeting and then present the question.`,
                    'high-level-design': `
**Current Stage: High-Level Design**
**Your Persona:** The "Strategic Reviewer."
**Your Objective:** To assess the user's high-level design for the problem: "${question}".
**Your Task:** Ask the user to describe a high-level block diagram, discuss core components (load balancers, databases, caches), and explain data flow. Probe for justifications behind these design choices. Evaluate the user's architectural vision and logical breakdown of the problem.`,
                    'deep-dive': `
**Current Stage: Deep Dive**
**Your Persona:** The "Technical Expert."
**Your Objective:** To challenge the user and test their in-depth knowledge of a specific component in their design for: "${question}".
**Your Task:** Pick a critical component from the user's design (e.g., the database, the caching layer, the message queue) and ask for a detailed deep dive. Ask about specific technologies, trade-offs (e.g., SQL vs. NoSQL), and potential bottlenecks. Act as a critical peer, raising "what if" scenarios. Evaluate the user's technical depth and ability to defend their design.`,
                    'scaling': `
**Current Stage: Scaling & Bottlenecks**
**Your Persona:** The "Pragmatic Engineer."
**Your Objective:** To push the user to consider scalability, potential failures, and edge cases for their design of: "${question}".
**Your Task:** Ask questions about what happens under extreme load, how the system handles failures (e.g., a database replica going down), and how to address complex edge cases (e.g., consistency issues, data loss). Evaluate the user's foresight and resilience-minded design.`,
                    'closing': `
**Current Stage: Conclusion**
**Your Persona:** The "Concluding Professional."
**Your Objective:** To wrap up the interview for the problem: "${question}".
**Your Task:** Summarize the conversation and invite the user's final questions. Assess the quality of the user's closing questions and their overall engagement.`,
                    'feedback': `
**Current Stage: Feedback Generation**
**Your Persona:** The "Constructive Reviewer."
**Your Objective:** To provide a detailed, actionable feedback report based on the entire interview for: "${question}".
**Your Task:** Based on the provided interview transcript and the evaluations from each stage, provide a comprehensive evaluation of the candidate's performance. The evaluation should include an overall rating (Strong Hire, Hire, Leaning No Hire, No Hire) and a detailed breakdown of their performance in the following areas: Communication, Requirements Gathering, High-Level Design, Deep Dive/Technical Depth, Trade-offs, and Problem-Solving. Also provide a summary of strengths and weaknesses, and actionable advice for improvement.

**Evaluations from each stage:**
${state.evaluations.map(e => `Stage: ${e.stage}\\nEvaluation: ${e.evaluation}`).join('\\n\\n')}

**Full Transcript:**
${history.map(m => {
                        if (Array.isArray(m.content)) {
                            const textPart = m.content.find(p => p.type === 'text');
                            return `${m.role}: ${textPart ? textPart.text : '[image]'}`;
                        }
                        return `${m.role}: ${m.content}`;
                    }).join('\\n')}
`
                };

                return `${basePrompt}\n\n${stagePrompts[stage]}`;
            },
            async sendMessage(message, model = "claude-sonnet-4") {

                if (!message) return;

                try {
                    const response = await puter.ai.chat(message, { model: model });

                    let responseText;
                    // Handle different response structures
                    if (typeof response === 'string') {
                        responseText = response; // OpenAI (string response)
                    } else if (response.message && response.message.content) {
                        if (Array.isArray(response.message.content) && response.message.content[0].text) {
                            responseText = response.message.content[0].text; // Claude
                        } else {
                            responseText = response.message.content; // Llama
                        }
                    } else {
                        responseText = JSON.stringify(response); // Fallback
                    }
                    return responseText;
                } catch (error) {
                    console.error("Error calling puter.ai.chat:", error);
                    return "An error occurred while communicating with the AI.";
                }
            },
            async run(stage, history, question, state) {
                const prompt = this.getPrompt(stage, question, history, state);
                const messages = [
                    { role: 'system', content: prompt },
                    ...history
                ];
                return this.sendMessage(messages);
            },
            async getEvaluation(stage, history, question) {
                const prompt = `You are an expert system design interviewer. Based on the following transcript of the '${stage}' stage of an interview for the problem '${question}', please provide a brief evaluation of the candidate's performance in this stage. Focus on the specific objectives of this stage.

Transcript:
${history.map(m => `${m.role}: ${m.content}`).join('\\n')}`;
                return this.sendMessage(messages);
            }
        };

        // --- State Management ---
        let interviewState = {
            stage: 'start', // 'start', 'clarification', 'high-level-design', 'deep-dive', 'scaling', 'closing', 'feedback'
            question: '',
            history: [],
            evaluations: [],
            stageStartTime: null,
            stageTimeLimits: {
                'clarification': 10 * 60 * 1000,
                'high-level-design': 15 * 60 * 1000,
                'deep-dive': 20 * 60 * 1000,
                'scaling': 7 * 60 * 1000,
                'closing': 3 * 60 * 1000,
            }
        };

        // --- UI Logic ---
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const questionSelect = document.getElementById('question-select');

        sendBtn.addEventListener('click', handleUserMessage);
        questionSelect.addEventListener('change', handleQuestionChange);
        userInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                handleUserMessage();
            }
        });

        async function handleUserMessage() {
            const messageText = userInput.value.trim();
            if (messageText === '') return;

            appendMessage('user', messageText);
            userInput.value = '';
            sendBtn.disabled = true;

            let userMessageContent = [{ type: 'text', text: messageText }];

            // Capture jsPlumb components if any exist
            const components = jsplumbContainer.querySelectorAll('.design-component');
            if (components.length > 0) {
                // Create a snapshot of the component diagram
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const containerRect = canvasContainer.getBoundingClientRect();

                tempCanvas.width = containerRect.width || 800;
                tempCanvas.height = containerRect.height || 600;

                // Set background
                tempCtx.fillStyle = '#1a1a1a';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                // Draw jsPlumb components
                tempCtx.font = '12px Arial';
                tempCtx.fillStyle = '#f0f0f0';

                components.forEach(component => {
                    const rect = component.getBoundingClientRect();
                    const containerRect = jsplumbContainer.getBoundingClientRect();
                    const x = rect.left - containerRect.left;
                    const y = rect.top - containerRect.top;

                    // Draw component rectangle
                    tempCtx.strokeStyle = getComputedStyle(component).borderColor || '#4CAF50';
                    tempCtx.lineWidth = 2;
                    tempCtx.strokeRect(x, y, rect.width, rect.height);

                    // Draw component background
                    tempCtx.fillStyle = getComputedStyle(component).backgroundColor || 'rgba(76, 175, 80, 0.1)';
                    tempCtx.fillRect(x, y, rect.width, rect.height);

                    // Draw component text
                    tempCtx.fillStyle = '#f0f0f0';
                    tempCtx.fillText(component.textContent, x + 5, y + 20);
                });

                // Draw connections (simplified representation)
                if (jsPlumbInstance) {
                    const connections = jsPlumbInstance.getAllConnections();
                    tempCtx.strokeStyle = '#f0f0f0';
                    tempCtx.lineWidth = 2;

                    connections.forEach(connection => {
                        const sourceElement = connection.source;
                        const targetElement = connection.target;

                        if (sourceElement && targetElement) {
                            const sourceRect = sourceElement.getBoundingClientRect();
                            const targetRect = targetElement.getBoundingClientRect();
                            const containerRect = jsplumbContainer.getBoundingClientRect();

                            const sourceX = sourceRect.left - containerRect.left + sourceRect.width / 2;
                            const sourceY = sourceRect.top - containerRect.top + sourceRect.height / 2;
                            const targetX = targetRect.left - containerRect.left + targetRect.width / 2;
                            const targetY = targetRect.top - containerRect.top + targetRect.height / 2;

                            tempCtx.beginPath();
                            tempCtx.moveTo(sourceX, sourceY);
                            tempCtx.lineTo(targetX, targetY);
                            tempCtx.stroke();
                        }
                    });
                }

                const imageBase64 = tempCanvas.toDataURL();
                const imageFile = await (await fetch(imageBase64)).blob();
                const puterFile = await puter.fs.write(`design_snapshot_${Date.now()}.png`, imageFile);
                userMessageContent.unshift({ type: 'file', puter_path: puterFile.path });
            }

            interviewState.history.push({ role: 'user', content: userMessageContent });

            const aiResponse = await orchestrator.run();

            interviewState.history.push({ role: 'assistant', content: aiResponse });
            appendMessage('ai', aiResponse);
            sendBtn.disabled = false;
        }

        function handleQuestionChange(event) {
            const selectedQuestion = event.target.value;
            if (selectedQuestion !== interviewState.question) {
                if (confirm('Do you want to reset the interview and start with the new question?')) {
                    orchestrator.resetAndStart(selectedQuestion);
                } else {
                    // Reset the dropdown to the current question if the user cancels
                    questionSelect.value = interviewState.question;
                }
            }
        }

        function appendMessage(sender, text) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message');
            messageElement.classList.add(sender === 'user' ? 'user-message' : 'ai-message');
            messageElement.innerText = text;
            chatContainer.appendChild(messageElement);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // --- Orchestrator ---
        const orchestrator = {
            questions: [
                "Design a URL shortening service (like Bitly).",
                "Design a social media feed (like Twitter or Facebook news feed).",
                "Design a distributed key-value store (like DynamoDB or Cassandra).",
                "Design a ride-sharing service backend (like Uber or Lyft).",
                "Design a video streaming service (like Netflix or YouTube).",
                "Design an e-commerce website (like Amazon).",
                "Design a web crawler (like Google's).",
                "Design a messaging app (like WhatsApp).",
                "Design a stock trading platform (like Robinhood).",
                "Design a distributed file storage system (like Google Drive).",
                "Design a rate-limiting system.",
                "Design a recommendation engine (like Amazon's product suggestions).",
                "Design a real-time multiplayer game backend.",
                "Design an online payment system (like Stripe).",
                "Design a hotel reservation system (like Booking.com).",
                "Design a web analytics platform (like Google Analytics).",
                "Design a distributed task scheduler (like a simplified version of Airflow).",
                "Design a push notification service.",
                "Design an API gateway for a microservices architecture.",
                "Design a distributed cache system (like Redis).",
                "Design a distributed logging and monitoring system (like the ELK stack).",
                "Design a geo-spatial index (for a service like Uber or Yelp).",
                "Design a system for live-streaming events (like Twitch or YouTube Live).",
                "Design a chat application with group chats.",
                "Design an online code editor (like Google Docs for code).",
                "Design a system for short-term stock trading."
            ],
            async transitionTo(newStage) {
                // Get evaluation for the previous stage before transitioning
                if (interviewState.stage !== 'start' && interviewState.stage !== 'feedback') {
                    const evaluation = await interviewerAgent.getEvaluation(interviewState.stage, interviewState.history, interviewState.question);
                    interviewState.evaluations.push({ stage: interviewState.stage, evaluation: evaluation });
                }
                interviewState.stage = newStage;
                interviewState.stageStartTime = Date.now();
            },
            async run() {
                const now = Date.now();
                const timeInStage = now - interviewState.stageStartTime;
                const timeLimit = interviewState.stageTimeLimits[interviewState.stage];

                if (timeLimit && timeInStage > timeLimit) {
                    await this.moveToNextStage();
                }

                switch (interviewState.stage) {
                    case 'start':
                        await this.transitionTo('clarification');
                        // interviewState.question is set in startInterview
                        return `Hi, welcome! Today, we'll be designing the following system: ${interviewState.question}. You have about 45 minutes. Please feel free to ask me any questions to clarify the requirements.`;
                    case 'clarification':
                    case 'high-level-design':
                    case 'deep-dive':
                    case 'scaling':
                    case 'closing':
                        return await interviewerAgent.run(interviewState.stage, interviewState.history, interviewState.question, interviewState);
                    case 'feedback':
                        return await interviewerAgent.run('feedback', interviewState.history, interviewState.question, interviewState);
                }
            },
            async moveToNextStage() {
                const stages = ['clarification', 'high-level-design', 'deep-dive', 'scaling', 'closing', 'feedback'];
                const currentStageIndex = stages.indexOf(interviewState.stage);
                if (currentStageIndex < stages.length - 1) {
                    await this.transitionTo(stages[currentStageIndex + 1]);
                }
            },
            async resetAndStart(newQuestion) {
                interviewState.stage = 'start';
                interviewState.question = newQuestion;
                interviewState.history = [];
                interviewState.evaluations = [];
                interviewState.stageStartTime = null;
                chatContainer.innerHTML = '';
                questionSelect.value = newQuestion;

                const firstMessage = await orchestrator.run();
                appendMessage('ai', firstMessage);
            }
        };

        // --- Initial Message ---
        async function startInterview() {
            sendBtn.disabled = true;
            orchestrator.questions.forEach(q => {
                const option = document.createElement('option');
                option.value = q;
                option.textContent = q;
                questionSelect.appendChild(option);
            });
            interviewState.question = orchestrator.questions[0];
            questionSelect.value = interviewState.question;

            const firstMessage = await orchestrator.run();
            appendMessage('ai', firstMessage);
            sendBtn.disabled = false;
        }

        startInterview();

        // === Connection Management Configuration ===
        const CONNECTION_CONFIG = {
            MAX_CLICK_DISTANCE: 100,     // Maximum distance to consider a click valid (pixels)
            BOUNDING_BOX_PADDING: 50,    // Padding around connection bounding box (pixels)
            DOM_READY_DELAY: 50,         // Delay before setting up connection listeners (ms)
            TOOLTIP_DURATION: 4000,      // How long to show connection help tooltip (ms)
            DEFAULT_ARROW_TYPE: 'one-way' // Default arrow type for new connections
        };

        // === Whiteboard State Variables ===
        const whiteboardCanvas = document.getElementById('whiteboard-canvas');
        const canvasContainer = document.querySelector('.canvas-container');
        const jsplumbContainer = document.getElementById('jsplumb-container');
        const contextMenu = document.getElementById('connection-context-menu');

        let canvas = null;
        let jsPlumbInstance = null;
        let componentCounter = 0;
        let connectionCounter = 0;
        let currentConnection = null;
        let lastConnection = null;

        // Connection registry using Map for efficient lookup by unique ID
        const connectionRegistry = new Map();

        function resizeCanvas() {
            if (!canvasContainer) return;
            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = canvasContainer.clientHeight;

            // Update jsPlumb container size
            if (jsplumbContainer) {
                jsplumbContainer.style.width = containerWidth + 'px';
                jsplumbContainer.style.height = containerHeight + 'px';
            }

            if (jsPlumbInstance) {
                jsPlumbInstance.repaintEverything();
            }
        }

        function initializeJsPlumb() {
            jsPlumbInstance = jsPlumb.getInstance({
                Container: jsplumbContainer,
                Endpoint: ["Dot", { radius: 3 }],
                Connector: "Bezier",
                HoverPaintStyle: { stroke: "#FFD700", strokeWidth: 2 },
                ConnectionOverlays: [
                    ["Arrow", { location: 1, width: 10, length: 8 }]
                ],
                PaintStyle: { stroke: "#f0f0f0", strokeWidth: 2 },
                EndpointStyle: { fill: "#f0f0f0" },
                DragOptions: { cursor: 'pointer', zIndex: 2000 }
            });

            // Add connection event listeners
            jsPlumbInstance.bind("connection", function (info) {
                // Generate a truly unique connection ID
                connectionCounter++;
                const originalId = info.connection.id;
                const uniqueId = `conn-${connectionCounter}-${Date.now()}`;

                // Override the connection ID with our unique one
                info.connection.id = uniqueId;
                info.connection.originalId = originalId;

                console.log(`New connection created: ${uniqueId} (original: ${originalId})`);

                // Set up the connection with default configuration
                setupConnection(info.connection);

                // Show help tooltip
                const helpDiv = document.getElementById('connection-help');
                if (helpDiv) {
                    helpDiv.classList.add('show');
                    setTimeout(() => {
                        helpDiv.classList.remove('show');
                    }, CONNECTION_CONFIG.TOOLTIP_DURATION);
                }
            });
        }

        // === Connection Identification Helper Functions ===

        /**
         * Clears conflicting DOM tags from connection elements to ensure pure geometric identification
         */
        function clearConflictingConnectionTags() {
            console.log('Clearing conflicting connection DOM tags...');
            const connectorElements = jsplumbContainer.querySelectorAll('.jtk-connector, path, svg');
            let clearedCount = 0;
            
            connectorElements.forEach(element => {
                if (element.hasAttribute('data-connection-id') || element._jsPlumbConnection) {
                    element.removeAttribute('data-connection-id');
                    delete element._jsPlumbConnection;
                    clearedCount++;
                }
            });
            
            console.log(`Cleared ${clearedCount} conflicting DOM tags`);
        }

        /**
         * Calculates the distance from a point to a line segment
         * @param {number} pointX - X coordinate of the point
         * @param {number} pointY - Y coordinate of the point
         * @param {number} x1 - X coordinate of line start
         * @param {number} y1 - Y coordinate of line start
         * @param {number} x2 - X coordinate of line end
         * @param {number} y2 - Y coordinate of line end
         * @returns {number} Distance from point to line
         */
        function calculateDistanceToLine(pointX, pointY, x1, y1, x2, y2) {
            const lineLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            if (lineLength === 0) return Infinity;

            return Math.abs(
                (y2 - y1) * pointX - (x2 - x1) * pointY + x2 * y1 - y2 * x1
            ) / lineLength;
        }

        /**
         * Checks if a point is within the bounding box of a connection
         * @param {number} clickX - X coordinate of click
         * @param {number} clickY - Y coordinate of click
         * @param {Object} sourceRect - Source component bounding rectangle
         * @param {Object} targetRect - Target component bounding rectangle
         * @param {number} padding - Padding around the bounding box
         * @returns {boolean} True if point is within bounds
         */
        function isWithinConnectionBounds(clickX, clickY, sourceRect, targetRect, padding = CONNECTION_CONFIG.BOUNDING_BOX_PADDING) {
            const sourceCenterX = sourceRect.left + sourceRect.width / 2;
            const sourceCenterY = sourceRect.top + sourceRect.height / 2;
            const targetCenterX = targetRect.left + targetRect.width / 2;
            const targetCenterY = targetRect.top + targetRect.height / 2;

            const minX = Math.min(sourceCenterX, targetCenterX) - padding;
            const maxX = Math.max(sourceCenterX, targetCenterX) + padding;
            const minY = Math.min(sourceCenterY, targetCenterY) - padding;
            const maxY = Math.max(sourceCenterY, targetCenterY) + padding;

            return clickX >= minX && clickX <= maxX && clickY >= minY && clickY <= maxY;
        }

        /**
         * Finds the connection closest to a click point using geometric calculations
         * @param {number} clickX - X coordinate of click
         * @param {number} clickY - Y coordinate of click
         * @returns {Object|null} The closest connection or null if none found
         */
        function findClosestConnection(clickX, clickY) {
            const allConnections = Array.from(connectionRegistry.values());

            if (allConnections.length === 0) {
                console.log('No connections available for identification');
                return null;
            }

            let closestConnection = null;
            let minDistance = Infinity;
            const MAX_CLICK_DISTANCE = CONNECTION_CONFIG.MAX_CLICK_DISTANCE;

            console.log(`Searching ${allConnections.length} connections for closest match to (${clickX}, ${clickY})`);

            for (const connection of allConnections) {
                if (!connection.source || !connection.target) {
                    console.log(`Skipping connection ${connection.id}: missing source or target`);
                    continue;
                }

                const sourceRect = connection.source.getBoundingClientRect();
                const targetRect = connection.target.getBoundingClientRect();

                // Check if click is within connection bounds first (performance optimization)
                if (!isWithinConnectionBounds(clickX, clickY, sourceRect, targetRect)) {
                    continue;
                }

                // Calculate distance to connection line
                const sourceCenterX = sourceRect.left + sourceRect.width / 2;
                const sourceCenterY = sourceRect.top + sourceRect.height / 2;
                const targetCenterX = targetRect.left + targetRect.width / 2;
                const targetCenterY = targetRect.top + targetRect.height / 2;

                const distance = calculateDistanceToLine(
                    clickX, clickY,
                    sourceCenterX, sourceCenterY,
                    targetCenterX, targetCenterY
                );

                console.log(`Connection ${connection.id}: distance=${distance.toFixed(2)}px`);

                if (distance < MAX_CLICK_DISTANCE && distance < minDistance) {
                    minDistance = distance;
                    closestConnection = connection;
                }
            }

            if (closestConnection) {
                console.log(`Found closest connection: ${closestConnection.id} (distance: ${minDistance.toFixed(2)}px)`);
            } else {
                console.log('No connection found within click tolerance');
            }

            return closestConnection;
        }

        /**
         * Attempts to identify a connection from a clicked DOM element
         * Uses connection ID-based identification as primary method
         * @param {HTMLElement} clickedElement - The DOM element that was clicked
         * @param {number} clickX - X coordinate of click
         * @param {number} clickY - Y coordinate of click
         * @returns {Object|null} The identified connection or null
         */
        function identifyConnectionFromClick(clickedElement, clickX, clickY) {
            console.log('Attempting connection identification using connection IDs...');

            // Strategy 1: Direct reference on element
            if (clickedElement._jsPlumbConnection) {
                const connection = clickedElement._jsPlumbConnection;
                console.log('‚úì Connection found via direct element reference:', connection.id);
                return connection;
            }

            // Strategy 2: Data attribute lookup
            if (clickedElement.hasAttribute('data-connection-id')) {
                const connectionId = clickedElement.getAttribute('data-connection-id');
                const connection = connectionRegistry.get(connectionId);
                if (connection) {
                    console.log('‚úì Connection found via data attribute:', connectionId);
                    return connection;
                }
            }

            // Strategy 3: Look for connection ID in parent elements
            let parentElement = clickedElement.parentElement;
            while (parentElement && parentElement !== jsplumbContainer) {
                if (parentElement._jsPlumbConnection) {
                    const connection = parentElement._jsPlumbConnection;
                    console.log('‚úì Connection found via parent element reference:', connection.id);
                    return connection;
                }
                if (parentElement.hasAttribute('data-connection-id')) {
                    const connectionId = parentElement.getAttribute('data-connection-id');
                    const connection = connectionRegistry.get(connectionId);
                    if (connection) {
                        console.log('‚úì Connection found via parent data attribute:', connectionId);
                        return connection;
                    }
                }
                parentElement = parentElement.parentElement;
            }

            // Strategy 4: Fallback - geometric calculation (as last resort)
            console.log('Trying geometric calculation as fallback...');
            const connection = findClosestConnection(clickX, clickY);
            if (connection) {
                console.log('‚úì Connection identified via geometric calculation (fallback):', connection.id);
                // Tag element for future reference
                clickedElement._jsPlumbConnection = connection;
                clickedElement.setAttribute('data-connection-id', connection.id);
                return connection;
            }

            console.log('‚úó No connection found using any method');
            return null;
        }
            /**
             * Sets up a new connection in the registry and applies default settings
             * @param {Object} connection - jsPlumb connection object
             */
            function setupConnection(connection) {
                console.log(`Setting up connection: ${connection.id}`);

                // Store connection in registry
                connectionRegistry.set(connection.id, connection);

                // Apply default arrow type
                connection.arrowType = CONNECTION_CONFIG.DEFAULT_ARROW_TYPE;
                updateConnectionArrows(connection);

                // Tag DOM elements for identification
                setTimeout(() => {
                    tagConnectionElements(connection);
                }, CONNECTION_CONFIG.DOM_READY_DELAY);

                // Track as last connection for fallback purposes
                lastConnection = connection;

                console.log(`Connection ${connection.id} setup complete. Registry size: ${connectionRegistry.size}`);
            }

            /**
             * Tags DOM elements associated with a connection for identification
             * @param {Object} connection - jsPlumb connection object
             */
            function tagConnectionElements(connection) {
                if (!connection || !connection.id) return;

                console.log(`Tagging DOM elements for connection: ${connection.id}`);

                // Find connection-related DOM elements
                const connectorElements = jsplumbContainer.querySelectorAll('.jtk-connector, path[d], svg');
                
                // Tag elements that don't already have a connection ID
                let taggedCount = 0;
                connectorElements.forEach(element => {
                    if (!element.hasAttribute('data-connection-id') && !element._jsPlumbConnection) {
                        element.setAttribute('data-connection-id', connection.id);
                        element._jsPlumbConnection = connection;
                        taggedCount++;
                        console.log(`Tagged element for connection ${connection.id}:`, element.tagName);
                        
                        // Only tag a reasonable number of elements to avoid over-tagging
                        if (taggedCount >= 2) return;
                    }
                });

                console.log(`Tagged ${taggedCount} elements for connection ${connection.id}`);
            }

            function createDesignComponent(type, x = 100, y = 100, customName = null) {
                componentCounter++;
                const componentId = `${type}-${componentCounter}`;

                const componentLabels = {
                    client: 'üì± Client',
                    server: 'üñ•Ô∏è Server',
                    database: 'üóÉÔ∏è Database',
                    cache: '‚ö° Cache',
                    gateway: 'üö™ API Gateway',
                    queue: 'üì¨ Queue',
                    balancer: '‚öñÔ∏è Load Balancer',
                    cdn: 'üåê CDN',
                    ai: 'ü§ñ AI',
                    storage: 'üíæ Storage',
                    custom: customName || 'üîß Custom'
                };

                const componentDiv = document.createElement('div');
                componentDiv.id = componentId;
                componentDiv.className = `design-component ${type}-component`;
                componentDiv.style.left = x + 'px';
                componentDiv.style.top = y + 'px';
                componentDiv.innerHTML = componentLabels[type] || type;

                jsplumbContainer.appendChild(componentDiv);

                // Make the component draggable and add connection endpoints
                jsPlumbInstance.draggable(componentDiv);

                // Add connection points (endpoints)
                jsPlumbInstance.addEndpoint(componentDiv, {
                    anchor: "Top",
                    isSource: true,
                    isTarget: true,
                    maxConnections: -1
                });
                jsPlumbInstance.addEndpoint(componentDiv, {
                    anchor: "Bottom",
                    isSource: true,
                    isTarget: true,
                    maxConnections: -1
                });
                jsPlumbInstance.addEndpoint(componentDiv, {
                    anchor: "Left",
                    isSource: true,
                    isTarget: true,
                    maxConnections: -1
                });
                jsPlumbInstance.addEndpoint(componentDiv, {
                    anchor: "Right",
                    isSource: true,
                    isTarget: true,
                    maxConnections: -1
                });

                return componentDiv;
            }

            /**
             * Shows the connection context menu at the specified coordinates
             * @param {Object} connection - The jsPlumb connection object
             * @param {number} clientX - X coordinate for menu positioning
             * @param {number} clientY - Y coordinate for menu positioning
             */
            function showConnectionContextMenu(connection, clientX, clientY) {
                console.log('Showing context menu for connection:', connection.id);

                // Store the current connection that was clicked
                currentConnection = connection;

                const contextMenu = document.getElementById('connection-context-menu');
                if (!contextMenu) {
                    console.error('Context menu element not found!');
                    return;
                }

                // Calculate menu position with boundary checking
                const { menuX, menuY } = calculateMenuPosition(clientX, clientY);

                // Position and show menu
                contextMenu.style.position = 'fixed';
                contextMenu.style.left = menuX + 'px';
                contextMenu.style.top = menuY + 'px';
                contextMenu.style.display = 'block';

                console.log('Context menu positioned at:', menuX, menuY);

                // Update active state indicators
                updateMenuActiveStates(contextMenu, connection);
                
                // Populate text input with current connection text
                const textInput = document.getElementById('connection-text-input');
                if (textInput) {
                    textInput.value = connection.text || '';
                    textInput.placeholder = 'Enter connection label...';
                }
            }

            /**
             * Calculates the optimal position for the context menu within viewport bounds
             * @param {number} clientX - X coordinate of the click
             * @param {number} clientY - Y coordinate of the click
             * @returns {Object} Object with menuX and menuY properties
             */
            function calculateMenuPosition(clientX, clientY) {
                const menuWidth = 180;
                const menuHeight = 180;
                const padding = 10;

                let menuX = clientX;
                let menuY = clientY;

                // Boundary checking
                if (menuX + menuWidth > window.innerWidth) {
                    menuX = window.innerWidth - menuWidth - padding;
                }
                if (menuY + menuHeight > window.innerHeight) {
                    menuY = window.innerHeight - menuHeight - padding;
                }
                if (menuX < padding) menuX = padding;
                if (menuY < padding) menuY = padding;

                return { menuX, menuY };
            }

            /**
             * Updates the active state of menu items based on the current connection
             * @param {HTMLElement} contextMenu - The context menu element
             * @param {Object} connection - The current connection object
             */
            function updateMenuActiveStates(contextMenu, connection) {
                const menuItems = contextMenu.querySelectorAll('.context-menu-item');
                menuItems.forEach(item => {
                    item.classList.remove('active');
                    const arrowType = item.getAttribute('data-arrow-type');
                    if (arrowType && connection.arrowType === arrowType) {
                        item.classList.add('active');
                    }
                });
            }

            // Connection arrow customization functions
            function updateConnectionArrows(connection) {
                console.log('updateConnectionArrows called with:', connection);
                
                if (!connection || !connection.arrowType) {
                    console.warn('updateConnectionArrows: Invalid connection or missing arrowType');
                    return;
                }

                // Validate connection object has required jsPlumb methods
                if (typeof connection.removeAllOverlays !== 'function') {
                    console.error('updateConnectionArrows: removeAllOverlays method missing');
                    return;
                }
                
                if (typeof connection.addOverlay !== 'function') {
                    console.error('updateConnectionArrows: addOverlay method missing');
                    return;
                }

                try {
                    console.log('Preserving text labels and updating arrows for connection:', connection.id);
                    
                    // Preserve existing text labels before removing overlays
                    let existingTextLabel = null;
                    const existingOverlays = connection.getOverlays();
                    Object.keys(existingOverlays).forEach(key => {
                        const overlay = existingOverlays[key];
                        if (overlay.type === 'Label') {
                            existingTextLabel = overlay.getLabel();
                        }
                    });
                    
                    console.log('Removing existing overlays for connection:', connection.id);
                    // Remove existing overlays
                    connection.removeAllOverlays();
                    
                    console.log('Adding new overlays for arrow type:', connection.arrowType);
                    // Add overlays based on arrow type
                    switch (connection.arrowType) {
                        case "one-way":
                            connection.addOverlay(["Arrow", {
                                location: 1,
                                width: 10,
                                length: 8,
                                foldback: 0.8
                            }]);
                            console.log('Added one-way arrow overlay');
                            break;
                        case "double":
                            connection.addOverlay(["Arrow", {
                                location: 1,
                                width: 10,
                                length: 8,
                                foldback: 0.8
                            }]);
                            connection.addOverlay(["Arrow", {
                                location: 0,
                                width: 10,
                                length: 8,
                                foldback: 0.8,
                                direction: -1
                            }]);
                            console.log('Added double arrow overlays');
                            break;
                        case "none":
                            console.log('No arrows added (none type)');
                            // No arrows, just the line
                            break;
                        default:
                            console.warn('Unknown arrow type:', connection.arrowType);
                    }
                    
                    // Restore text label if it existed
                    if (existingTextLabel && existingTextLabel.trim() !== '') {
                        const labelId = `label-${connection.id}`;
                        connection.addOverlay([
                            "Label", 
                            {
                                id: labelId,
                                label: existingTextLabel,
                                location: 0.5,
                                cssClass: "connection-label",
                                events: {
                                    dblclick: function(labelOverlay, originalEvent) {
                                        originalEvent.stopPropagation();
                                        showConnectionContextMenu(connection, originalEvent.clientX, originalEvent.clientY);
                                    }
                                }
                            }
                        ]);
                        console.log(`Restored text label "${existingTextLabel}" after arrow update`);
                        
                        // Update connection.text to maintain consistency
                        connection.text = existingTextLabel;
                    }

                    // Update visual appearance
                    console.log('Repainting connection...');
                    if (jsPlumbInstance) {
                        try {
                            // Try multiple repaint strategies
                            if (connection.source && connection.target) {
                                // Repaint the source and target elements
                                jsPlumbInstance.repaint(connection.source);
                                jsPlumbInstance.repaint(connection.target);
                                console.log('Source and target elements repainted successfully');
                            } else {
                                // Fallback to repaint everything
                                jsPlumbInstance.repaintEverything();
                                console.log('All connections repainted successfully (fallback)');
                            }
                        } catch (repaintError) {
                            console.warn('Repaint failed, trying repaintEverything:', repaintError.message);
                            jsPlumbInstance.repaintEverything();
                        }
                    } else {
                        console.error('jsPlumbInstance not available');
                    }
                } catch (error) {
                    console.error('Error updating connection arrows:', error);
                    console.error('Error stack:', error.stack);
                    console.error('Connection object details:', {
                        id: connection.id,
                        type: typeof connection,
                        constructor: connection.constructor?.name,
                        arrowType: connection.arrowType,
                        hasRemoveAllOverlays: typeof connection.removeAllOverlays,
                        hasAddOverlay: typeof connection.addOverlay
                    });
                }
            }

            /**
             * Updates the text label on a connection
             * @param {Object} connection - jsPlumb connection object
             * @param {string} text - Text to display on the connection
             */
            function updateConnectionText(connection, text) {
                if (!connection) {
                    console.warn('updateConnectionText: Invalid connection');
                    return;
                }

                console.log(`Updating text for connection ${connection.id}: "${text}"`);

                try {
                    // Remove existing text overlays
                    const existingOverlays = connection.getOverlays();
                    Object.keys(existingOverlays).forEach(key => {
                        const overlay = existingOverlays[key];
                        if (overlay.type === 'Label') {
                            connection.removeOverlay(key);
                        }
                    });

                    // Add new text overlay if text is provided
                    if (text && text.trim() !== '') {
                        const labelId = `label-${connection.id}`;
                        connection.addOverlay([
                            "Label", 
                            {
                                id: labelId,
                                label: text,
                                location: 0.5,
                                cssClass: "connection-label",
                                events: {
                                    dblclick: function(labelOverlay, originalEvent) {
                                        // Allow editing text by double-clicking the label
                                        originalEvent.stopPropagation();
                                        showConnectionContextMenu(connection, originalEvent.clientX, originalEvent.clientY);
                                    }
                                }
                            }
                        ]);
                        console.log(`Added text label "${text}" to connection ${connection.id}`);
                    } else {
                        console.log(`Removed text label from connection ${connection.id}`);
                    }

                    // Repaint the connection
                    if (connection.source && connection.target) {
                        jsPlumbInstance.repaint(connection.source);
                        jsPlumbInstance.repaint(connection.target);
                    }
                } catch (error) {
                    console.error('Error updating connection text:', error);
                }
            }

            function hideConnectionContextMenu() {
                const contextMenu = document.getElementById('connection-context-menu');
                if (contextMenu) {
                    contextMenu.style.display = 'none';
                }
                currentConnection = null;
            }

            function initializeWhiteboard() {
                if (jsPlumbInstance) return;

                // Initialize jsPlumb only
                initializeJsPlumb();

                // Initial resize
                resizeCanvas();

                // Resize on window resize
                window.addEventListener('resize', resizeCanvas);

                // Component palette event listeners
                const componentBtns = document.querySelectorAll('.component-btn');
                componentBtns.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const componentType = e.target.getAttribute('data-component');
                        if (componentType) {
                            const rect = jsplumbContainer.getBoundingClientRect();
                            const x = Math.random() * (rect.width - 100) + 50;
                            const y = Math.random() * (rect.height - 100) + 50;

                            if (componentType === 'custom') {
                                // Prompt user for custom component name
                                const customName = prompt('Enter a name for your custom component:', 'Custom Component');
                                if (customName && customName.trim() !== '') {
                                    const displayName = customName.length > 20 ? customName.substring(0, 17) + '...' : customName;
                                    createDesignComponent(componentType, x, y, 'üîß ' + displayName);
                                }
                            } else {
                                createDesignComponent(componentType, x, y);
                            }
                        }
                    });
                });

                const contextMenu = document.getElementById('connection-context-menu');

                // Context menu event listeners
                const contextMenuItems = contextMenu.querySelectorAll('.context-menu-item');
                contextMenuItems.forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();

                        console.log('Context menu item clicked:', item.dataset.arrowType || item.dataset.action);

                        // Store the connection reference before hiding the menu
                        const connectionToModify = currentConnection;

                        // Hide menu immediately to prevent any delays
                        hideConnectionContextMenu();

                        // Process the action using the stored connection reference
                        if (item.dataset.arrowType && connectionToModify) {
                            console.log('Updating arrow type to:', item.dataset.arrowType, 'for connection:', connectionToModify.id);
                            connectionToModify.arrowType = item.dataset.arrowType;
                            updateConnectionArrows(connectionToModify);
                        } else if (item.dataset.action === 'delete' && connectionToModify) {
                            console.log('Deleting connection:', connectionToModify.id);
                            connectionRegistry.delete(connectionToModify.id);
                            jsPlumbInstance.deleteConnection(connectionToModify);
                            if (lastConnection === connectionToModify) {
                                const remainingConnections = Array.from(connectionRegistry.values());
                                lastConnection = remainingConnections.length > 0 ? remainingConnections[remainingConnections.length - 1] : null;
                            }
                        }
                    });
                });

                // Text update button event listener
                const updateTextBtn = document.getElementById('update-text-btn');
                if (updateTextBtn) {
                    updateTextBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        
                        const textInput = document.getElementById('connection-text-input');
                        const connectionToModify = currentConnection;
                        
                        if (textInput && connectionToModify) {
                            const newText = textInput.value.trim();
                            console.log('Updating connection text to:', newText, 'for connection:', connectionToModify.id);
                            
                            // Store text on connection object
                            connectionToModify.text = newText;
                            
                            // Update connection with text label
                            updateConnectionText(connectionToModify, newText);
                            
                            // Hide menu
                            hideConnectionContextMenu();
                        }
                    });
                }

                // Enter key support for text input
                const textInput = document.getElementById('connection-text-input');
                if (textInput) {
                    textInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            document.getElementById('update-text-btn').click();
                        }
                    });
                }

                // Global click handler to hide context menu
                document.addEventListener('click', (e) => {
                    const contextMenu = document.getElementById('connection-context-menu');
                    if (contextMenu && !contextMenu.contains(e.target) && contextMenu.style.display === 'block') {
                        hideConnectionContextMenu();
                    }
                });

                // === Global Event Handlers ===

                /**
                 * Handles double-click events on connection elements
                 * Shows the connection context menu for the clicked connection
                 */
                jsplumbContainer.addEventListener('dblclick', (e) => {
                    console.log('\n=== Connection Double-Click Event ===');
                    console.log('Target element:', e.target.tagName, e.target.classList.toString());
                    console.log('Click coordinates:', e.clientX, e.clientY);

                    // Only handle clicks on connection-related elements
                    const isConnectionElement = e.target.classList.contains('jtk-connector') ||
                        e.target.tagName === 'path' ||
                        e.target.classList.contains('jtk-connector-outline');

                    if (!isConnectionElement) {
                        console.log('Click target is not a connection element, ignoring');
                        return;
                    }

                    e.preventDefault();
                    e.stopPropagation();

                    // Identify the connection using our robust identification system
                    const targetConnection = identifyConnectionFromClick(e.target, e.clientX, e.clientY);

                    if (targetConnection) {
                        console.log('‚úì Connection identified, showing context menu for:', targetConnection.id);
                        showConnectionContextMenu(targetConnection, e.clientX, e.clientY);
                    } else {
                        console.log('‚úó No connection identified for this click');
                    }

                    console.log('=== End Double-Click Event ===\n');
                });

                // Global right-click handler with connection ID support
                jsplumbContainer.addEventListener('contextmenu', (e) => {
                    if (e.target.classList.contains('jtk-connector') ||
                        e.target.tagName === 'path' ||
                        e.target.classList.contains('jtk-connector-outline')) {

                        e.preventDefault();
                        e.stopPropagation();

                        console.log('Right-click on connection, target:', e.target);

                        // Use connection ID-based identification - same as double-click
                        const targetConnection = identifyConnectionFromClick(e.target, e.clientX, e.clientY);

                        if (targetConnection) {
                            console.log('Right-click handler using connection:', targetConnection.id);
                            showConnectionContextMenu(targetConnection, e.clientX, e.clientY);
                        } else {
                            console.log('Right-click: No connection identified');
                        }
                    } else {
                        // Prevent default context menu on other areas
                        e.preventDefault();
                    }
                });
            } // End of initializeWhiteboard function

            // Clear all components function
            function clearAllComponents() {
                if (confirm('Are you sure you want to clear all components?')) {
                    // Hide context menu if open
                    hideConnectionContextMenu();

                    // Clear the connection registry
                    connectionRegistry.clear();
                    console.log('Cleared connection registry');

                    // Clear all jsPlumb connections and components
                    if (jsPlumbInstance) {
                        jsPlumbInstance.deleteEveryEndpoint();
                        jsPlumbInstance.deleteEveryConnection();
                    }
                    // Remove all design components
                    const components = jsplumbContainer.querySelectorAll('.design-component');
                    components.forEach(component => {
                        component.remove();
                    });
                    componentCounter = 0;
                    connectionCounter = 0; // Reset connection counter for unique IDs
                    lastConnection = null;
                }
            }

            // Add clear button to components palette
            const clearButton = document.createElement('button');
            clearButton.className = 'component-btn';
            clearButton.style.backgroundColor = '#f44336';
            clearButton.style.color = 'white';
            clearButton.innerHTML = 'üóëÔ∏è Clear All';
            clearButton.addEventListener('click', clearAllComponents);
            document.getElementById('components-palette').appendChild(clearButton);

            // Initialize Split.js
            Split(['#whiteboard-area', '#chat-area'], {
                sizes: [75, 25],
                minSize: [400, 250],
                gutterSize: 10,
                cursor: 'col-resize',
                onDrag: resizeCanvas,
            });

            // Initialize the whiteboard on load
            initializeWhiteboard();
    </script>
</body>
</html>
