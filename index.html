<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI System Design Mock Interviewer</title>
    <script src="https://js.puter.com/v2/"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/split.js/1.6.2/split.min.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
Helvetica, Arial, sans-serif;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        h1 {
            color: #FFD700;
            text-align: center;
            margin-top: 0;
        }
        #main-container {
            display: flex;
            flex-grow: 1;
            gap: 0; /* Remove gap, gutter will handle spacing */
            min-height: 0;
            width: 100%;
            height: calc(100% - 80px); /* Adjust height for the title */
        }
        #whiteboard-area {
            /* flex: 3; */ /* Split.js will handle the width */
            border: 1px solid #555;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            padding: 15px;
            overflow: hidden;
        }
        #chat-area {
            /* flex: 1; */ /* Split.js will handle the width */
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow: hidden;
            padding: 0 15px;
            box-sizing: border-box;
        }
        .gutter {
            background-color: #333;
            background-repeat: no-repeat;
            background-position: 50%;
        }
        .gutter.gutter-horizontal {
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bM/5+BgeE4ARCMGkvGEgZgSpcRzQEAUg4fV4sO4sAAAAAASUVORK5CYII=');
            cursor: col-resize;
        }
        .group-wrapper {
            padding: 15px;
            border: 1px solid #555;
            border-radius: 5px;
            background-color: #222;
        }
        #whiteboard-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        #color-picker {
            border: 1px solid #555;
            border-radius: 5px;
            background-color: #333;
            cursor: pointer;
            height: 38px;
            width: 50px;
        }
        .canvas-container {
            flex-grow: 1;
            position: relative;
        }
        #whiteboard-canvas {
            border: 1px solid #444;
            border-radius: 5px;
            position: absolute;
            top: 0;
            left: 0;
        }

        #chat-container {
            border: 1px solid #444;
            border-radius: 5px;
            padding: 20px;
            overflow-y: scroll;
            background-color: #222;
            flex-grow: 1;
            min-height: 0;
        }
        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 5px;
        }
        .user-message {
            text-align: right;
            background-color: #333;
        }
        .ai-message {
            text-align: left;
            background-color: #2a2a2a;
        }
        #input-container {
            display: flex;
            flex-direction: column;
            margin-top: 20px;
        }
        #user-input {
            flex-grow: 1;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: #f0f0f0;
            width: 100%;
            box-sizing: border-box;
        }
        .action-button {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            background-color: #FFD700;
            color: black;
            cursor: pointer;
            font-size: 16px;
        }
        #send-btn {
            margin-top: 10px;
            width: 100px;
            align-self: flex-end;
        }
        #send-btn:disabled {
            background-color: #444;
            color: #888;
            cursor: not-allowed;
        }
        .group-wrapper {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #555;
            border-radius: 5px;
        }
        label {
            margin-right: 10px;
        }
        #toggle-whiteboard-btn {
            width: 200px;
        }
        #whiteboard-controls {
            display: flex;
            gap: 10px;
        }
    </style>
</head>
<body>
    <h1>AI System Design Mock Interviewer</h1>

    <div id="main-container">
        <div id="whiteboard-area">
            <div id="whiteboard-controls">
                <input type="color" id="color-picker" value="#f0f0f0">
                <button id="pencil-btn" class="action-button">Pencil</button>
                <button id="line-btn" class="action-button">Line</button>
                <button id="arrow-btn" class="action-button">Arrow</button>
                <button id="rect-btn" class="action-button">Rectangle</button>
                <button id="circle-btn" class="action-button">Circle</button>
                <button id="text-btn" class="action-button">Text</button>
                <button id="delete-btn" class="action-button">Delete</button>
                <button id="clear-btn" class="action-button">Clear</button>
            </div>
            <div class="canvas-container">
                <canvas id="whiteboard-canvas"></canvas>
            </div>
        </div>
        
        <div id="chat-area">
            <div class="group-wrapper">
                <label for="question-select">Select a System Design Question:</label>
                <select id="question-select"></select>
            </div>
        
            <div id="chat-container"></div>
            
            <div id="input-container">
                <textarea id="user-input" placeholder="Type your response here..."></textarea>
                <button id="send-btn" class="action-button">Send</button>
            </div>
        </div>
    </div>

    <script>
        // --- Agent Definitions ---
        const interviewerAgent = {
            getPrompt(stage, question = '', history = [], state = {}) {
                const basePrompt = `You are a system design mock interviewer, a seasoned and knowledgeable expert in software architecture. Your primary goal is to simulate a realistic system design interview for a candidate.

**Personality:** You are patient, supportive, and articulate, but also challenging. You'll act as a peer, not just an interrogator. Your tone should be encouraging, focusing on guiding the candidate toward a good solution rather than simply catching them in a mistake. Use clarifying questions to probe deeper into their reasoning.

**Meta-Instructions:**
- You must wait for the candidate's response at each stage. Do not rush them.
- Your primary objective is to evaluate their thought process, not just their final answer.
- Maintain a conversational and encouraging tone throughout the interview.`;

                const stagePrompts = {
                    'clarification': `
**Current Stage: Requirements Clarification**
**Your Persona:** The "Helpful Colleague."
**Your Objective:** To guide the user in clarifying functional and non-functional requirements for the following problem: "${question}".
**Your Task:** Ask questions about features, user scale, latency, availability, security, and other critical constraints. Evaluate the user's ability to ask clarifying questions and their understanding of the problem's scope.
Start the conversation with a friendly greeting and then present the question.`,
                    'high-level-design': `
**Current Stage: High-Level Design**
**Your Persona:** The "Strategic Reviewer."
**Your Objective:** To assess the user's high-level design for the problem: "${question}".
**Your Task:** Ask the user to describe a high-level block diagram, discuss core components (load balancers, databases, caches), and explain data flow. Probe for justifications behind these design choices. Evaluate the user's architectural vision and logical breakdown of the problem.`,
                    'deep-dive': `
**Current Stage: Deep Dive**
**Your Persona:** The "Technical Expert."
**Your Objective:** To challenge the user and test their in-depth knowledge of a specific component in their design for: "${question}".
**Your Task:** Pick a critical component from the user's design (e.g., the database, the caching layer, the message queue) and ask for a detailed deep dive. Ask about specific technologies, trade-offs (e.g., SQL vs. NoSQL), and potential bottlenecks. Act as a critical peer, raising "what if" scenarios. Evaluate the user's technical depth and ability to defend their design.`,
                    'scaling': `
**Current Stage: Scaling & Bottlenecks**
**Your Persona:** The "Pragmatic Engineer."
**Your Objective:** To push the user to consider scalability, potential failures, and edge cases for their design of: "${question}".
**Your Task:** Ask questions about what happens under extreme load, how the system handles failures (e.g., a database replica going down), and how to address complex edge cases (e.g., consistency issues, data loss). Evaluate the user's foresight and resilience-minded design.`,
                    'closing': `
**Current Stage: Conclusion**
**Your Persona:** The "Concluding Professional."
**Your Objective:** To wrap up the interview for the problem: "${question}".
**Your Task:** Summarize the conversation and invite the user's final questions. Assess the quality of the user's closing questions and their overall engagement.`,
                    'feedback': `
**Current Stage: Feedback Generation**
**Your Persona:** The "Constructive Reviewer."
**Your Objective:** To provide a detailed, actionable feedback report based on the entire interview for: "${question}".
**Your Task:** Based on the provided interview transcript and the evaluations from each stage, provide a comprehensive evaluation of the candidate's performance. The evaluation should include an overall rating (Strong Hire, Hire, Leaning No Hire, No Hire) and a detailed breakdown of their performance in the following areas: Communication, Requirements Gathering, High-Level Design, Deep Dive/Technical Depth, Trade-offs, and Problem-Solving. Also provide a summary of strengths and weaknesses, and actionable advice for improvement.

**Evaluations from each stage:**
${state.evaluations.map(e => `Stage: ${e.stage}\\nEvaluation: ${e.evaluation}`).join('\\n\\n')}

**Full Transcript:**
${history.map(m => {
    if (Array.isArray(m.content)) {
        const textPart = m.content.find(p => p.type === 'text');
        return `${m.role}: ${textPart ? textPart.text : '[image]'}`;
    }
    return `${m.role}: ${m.content}`;
}).join('\\n')}
`
                };

                return `${basePrompt}\n\n${stagePrompts[stage]}`;
            },
			async sendMessage(message, model = "claude-sonnet-4") {

				if (!message) return;

                try {
				    const response = await puter.ai.chat(message, { model: model });

                    let responseText;
                    // Handle different response structures
                    if (typeof response === 'string') {
                        responseText = response; // OpenAI (string response)
                    } else if (response.message && response.message.content) {
                        if (Array.isArray(response.message.content) && response.message.content[0].text) {
                            responseText = response.message.content[0].text; // Claude
                        } else {
                            responseText = response.message.content; // Llama
                        }
                    } else {
                        responseText = JSON.stringify(response); // Fallback
                    }
                    return responseText;
                } catch (error) {
                    console.error("Error calling puter.ai.chat:", error);
                    return "An error occurred while communicating with the AI.";
                }
			},
            async run(stage, history, question, state) {
                const prompt = this.getPrompt(stage, question, history, state);
                const messages = [
                    { role: 'system', content: prompt },
                    ...history
                ];
                return this.sendMessage(messages);
            },
            async getEvaluation(stage, history, question) {
                const prompt = `You are an expert system design interviewer. Based on the following transcript of the '${stage}' stage of an interview for the problem '${question}', please provide a brief evaluation of the candidate's performance in this stage. Focus on the specific objectives of this stage.

Transcript:
${history.map(m => `${m.role}: ${m.content}`).join('\\n')}`;
                return this.sendMessage(messages);
            }
        };

        // --- State Management ---
        let interviewState = {
            stage: 'start', // 'start', 'clarification', 'high-level-design', 'deep-dive', 'scaling', 'closing', 'feedback'
            question: '',
            history: [],
            evaluations: [],
            stageStartTime: null,
            stageTimeLimits: {
                'clarification': 10 * 60 * 1000,
                'high-level-design': 15 * 60 * 1000,
                'deep-dive': 20 * 60 * 1000,
                'scaling': 7 * 60 * 1000,
                'closing': 3 * 60 * 1000,
            }
        };

        // --- UI Logic ---
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const questionSelect = document.getElementById('question-select');

        sendBtn.addEventListener('click', handleUserMessage);
        questionSelect.addEventListener('change', handleQuestionChange);
        userInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                handleUserMessage();
            }
        });

        async function handleUserMessage() {
            const messageText = userInput.value.trim();
            if (messageText === '') return;

            appendMessage('user', messageText);
            userInput.value = '';
            sendBtn.disabled = true;

            let userMessageContent = [{ type: 'text', text: messageText }];

            if (canvas && canvas.getObjects().length > 0) {
                const imageBase64 = canvas.toDataURL();
                const imageFile = await (await fetch(imageBase64)).blob();
                const puterFile = await puter.fs.write(`whiteboard_snapshot_${Date.now()}.png`, imageFile);
                userMessageContent.unshift({ type: 'file', puter_path: puterFile.path });
            }

            interviewState.history.push({ role: 'user', content: userMessageContent });
            
            const aiResponse = await orchestrator.run();
            
            interviewState.history.push({ role: 'assistant', content: aiResponse });
            appendMessage('ai', aiResponse);
            sendBtn.disabled = false;
        }

        function handleQuestionChange(event) {
            const selectedQuestion = event.target.value;
            if (selectedQuestion !== interviewState.question) {
                if (confirm('Do you want to reset the interview and start with the new question?')) {
                    orchestrator.resetAndStart(selectedQuestion);
                } else {
                    // Reset the dropdown to the current question if the user cancels
                    questionSelect.value = interviewState.question;
                }
            }
        }
        
        function appendMessage(sender, text) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message');
            messageElement.classList.add(sender === 'user' ? 'user-message' : 'ai-message');
            messageElement.innerText = text;
            chatContainer.appendChild(messageElement);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // --- Orchestrator ---
        const orchestrator = {
            questions: [
                "Design a URL shortening service (like Bitly).",
                "Design a social media feed (like Twitter or Facebook news feed).",
                "Design a distributed key-value store (like DynamoDB or Cassandra).",
                "Design a ride-sharing service backend (like Uber or Lyft).",
                "Design a video streaming service (like Netflix or YouTube).",
                "Design an e-commerce website (like Amazon).",
                "Design a web crawler (like Google's).",
                "Design a messaging app (like WhatsApp).",
                "Design a stock trading platform (like Robinhood).",
                "Design a distributed file storage system (like Google Drive).",
                "Design a rate-limiting system.",
				"Design a recommendation engine (like Amazon's product suggestions).",
				"Design a real-time multiplayer game backend.",
				"Design an online payment system (like Stripe).",
				"Design a hotel reservation system (like Booking.com).",
				"Design a web analytics platform (like Google Analytics).",
				"Design a distributed task scheduler (like a simplified version of Airflow).",
				"Design a push notification service.",
				"Design an API gateway for a microservices architecture.",
				"Design a distributed cache system (like Redis).",
				"Design a distributed logging and monitoring system (like the ELK stack).",
				"Design a geo-spatial index (for a service like Uber or Yelp).",
				"Design a system for live-streaming events (like Twitch or YouTube Live).",
				"Design a chat application with group chats.",
				"Design an online code editor (like Google Docs for code).",
				"Design a system for short-term stock trading."
            ],
            async transitionTo(newStage) {
                // Get evaluation for the previous stage before transitioning
                if (interviewState.stage !== 'start' && interviewState.stage !== 'feedback') {
                    const evaluation = await interviewerAgent.getEvaluation(interviewState.stage, interviewState.history, interviewState.question);
                    interviewState.evaluations.push({ stage: interviewState.stage, evaluation: evaluation });
                }
                interviewState.stage = newStage;
                interviewState.stageStartTime = Date.now();
            },
            async run() {
                const now = Date.now();
                const timeInStage = now - interviewState.stageStartTime;
                const timeLimit = interviewState.stageTimeLimits[interviewState.stage];

                if (timeLimit && timeInStage > timeLimit) {
                    await this.moveToNextStage();
                }

                switch (interviewState.stage) {
                    case 'start':
                        await this.transitionTo('clarification');
                        // interviewState.question is set in startInterview
                        return `Hi, welcome! Today, we'll be designing the following system: ${interviewState.question}. You have about 45 minutes. Please feel free to ask me any questions to clarify the requirements.`;
                    case 'clarification':
                    case 'high-level-design':
                    case 'deep-dive':
                    case 'scaling':
                    case 'closing':
                        return await interviewerAgent.run(interviewState.stage, interviewState.history, interviewState.question, interviewState);
                    case 'feedback':
                        return await interviewerAgent.run('feedback', interviewState.history, interviewState.question, interviewState);
                }
            },
            async moveToNextStage() {
                const stages = ['clarification', 'high-level-design', 'deep-dive', 'scaling', 'closing', 'feedback'];
                const currentStageIndex = stages.indexOf(interviewState.stage);
                if (currentStageIndex < stages.length - 1) {
                    await this.transitionTo(stages[currentStageIndex + 1]);
                }
            },
            async resetAndStart(newQuestion) {
                interviewState.stage = 'start';
                interviewState.question = newQuestion;
                interviewState.history = [];
                interviewState.evaluations = [];
                interviewState.stageStartTime = null;
                chatContainer.innerHTML = '';
                questionSelect.value = newQuestion;
                
                const firstMessage = await orchestrator.run();
                appendMessage('ai', firstMessage);
            }
        };

        // --- Initial Message ---
        async function startInterview() {
            sendBtn.disabled = true;
            orchestrator.questions.forEach(q => {
                const option = document.createElement('option');
                option.value = q;
                option.textContent = q;
                questionSelect.appendChild(option);
            });
            interviewState.question = orchestrator.questions[0];
            questionSelect.value = interviewState.question;

            const firstMessage = await orchestrator.run();
            appendMessage('ai', firstMessage);
            sendBtn.disabled = false;
        }

        startInterview();

        // --- Whiteboard Logic ---
        const whiteboardCanvas = document.getElementById('whiteboard-canvas');
        const colorPicker = document.getElementById('color-picker');
        const pencilBtn = document.getElementById('pencil-btn');
        const lineBtn = document.getElementById('line-btn');
        const arrowBtn = document.getElementById('arrow-btn');
        const rectBtn = document.getElementById('rect-btn');
        const circleBtn = document.getElementById('circle-btn');
        const textBtn = document.getElementById('text-btn');
        const deleteBtn = document.getElementById('delete-btn');
        const clearBtn = document.getElementById('clear-btn');
        const canvasContainer = document.querySelector('.canvas-container');
        let canvas = null;
        let currentColor = '#ffffff';
        let drawingTool = 'pencil';
        let isDrawing = false;
        let startX, startY;
        let currentLine, currentArrow;

        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            if (canvas.freeDrawingBrush) {
                canvas.freeDrawingBrush.color = currentColor;
            }
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                if (activeObject.type === 'rect' || activeObject.type === 'circle') {
                    activeObject.set('stroke', currentColor);
                } else {
                    activeObject.set('fill', currentColor);
                }
                canvas.renderAll();
            }
        });

        function resizeCanvas() {
            if (!canvas || !canvasContainer) return;
            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = canvasContainer.clientHeight;
            canvas.setWidth(containerWidth);
            canvas.setHeight(containerHeight);
            canvas.renderAll();
        }

        function initializeWhiteboard() {
            if (canvas) return;
            canvas = new fabric.Canvas('whiteboard-canvas', {
                isDrawingMode: true
            });

            canvas.on('mouse:down', function(o) {
                if (drawingTool === 'delete') {
                    if (o.target) {
                        canvas.remove(o.target);
                    }
                    return;
                }

                if (drawingTool === 'line' || drawingTool === 'arrow'){
					isDrawing = true;
					canvas.selection = false;
					const pointer = canvas.getPointer(o.e);
					startX = pointer.x;
					startY = pointer.y;

					if (drawingTool === 'line') {
						const points = [startX, startY, startX, startY];
						currentLine = new fabric.Line(points, {
							stroke: currentColor,
							strokeWidth: 2,
						});
						canvas.add(currentLine);
					} else if (drawingTool === 'arrow') {
						currentArrow = createArrow(startX, startY, startX, startY);
						canvas.add(currentArrow);
					}
				}
            });

            canvas.on('mouse:move', function(o) {
                if (!isDrawing) return;
                const pointer = canvas.getPointer(o.e);

                if (drawingTool === 'line' && currentLine) {
                    currentLine.set({ x2: pointer.x, y2: pointer.y });
                    canvas.renderAll();
                } else if (drawingTool === 'arrow' && currentArrow) {
                    canvas.remove(currentArrow);
                    currentArrow = createArrow(startX, startY, pointer.x, pointer.y);
                    canvas.add(currentArrow);
                }
            });

            canvas.on('mouse:up', function(o) {
                if (!isDrawing) return;
                isDrawing = false;
                canvas.selection = true;
                if (currentLine) {
                    currentLine.setCoords();
                    currentLine = null;
                }
                if (currentArrow) {
                    currentArrow.setCoords();
                    currentArrow = null;
                }
            });

            // Initial resize
            resizeCanvas();

            // Resize canvas on window resize
            window.addEventListener('resize', resizeCanvas);
        }


        function selectTool(tool) {
            drawingTool = tool;
            canvas.isDrawingMode = (tool === 'pencil');
            if (tool === 'pencil') {
                canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush.color = currentColor;
                canvas.freeDrawingBrush.width = 2;
            }
        }

        pencilBtn.addEventListener('click', () => selectTool('pencil'));
        lineBtn.addEventListener('click', () => selectTool('line'));
        arrowBtn.addEventListener('click', () => selectTool('arrow'));
        deleteBtn.addEventListener('click', () => selectTool('delete'));

        rectBtn.addEventListener('click', () => {
            selectTool('rect');
            if (canvas) {
                const rect = new fabric.Rect({
                    left: 100,
                    top: 100,
                    fill: 'transparent',
                    stroke: currentColor,
                    strokeWidth: 2,
                    width: 150,
                    height: 100,
                });
                canvas.add(rect);
            }
        });

        circleBtn.addEventListener('click', () => {
            selectTool('circle');
            if (canvas) {
                const circle = new fabric.Circle({
                    left: 100,
                    top: 100,
                    fill: 'transparent',
                    stroke: currentColor,
                    strokeWidth: 2,
                    radius: 50,
                });
                canvas.add(circle);
            }
        });

        textBtn.addEventListener('click', () => {
            selectTool('text');
            if (canvas) {
                const text = new fabric.IText('Type here...', {
                    left: 100,
                    top: 100,
                    fill: currentColor,
                    fontSize: 40,
                    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif'
                });
                canvas.add(text);
                canvas.setActiveObject(text);
                text.enterEditing();
            }
        });

        function createArrow(fromX, fromY, toX, toY) {
            const angle = Math.atan2(toY - fromY, toX - fromX);
            const headlen = 10;

            const line = new fabric.Line([fromX, fromY, toX, toY], {
                stroke: currentColor,
                strokeWidth: 2,
            });

            const arrowhead = new fabric.Triangle({
                left: toX,
                top: toY,
                originX: 'center',
                originY: 'center',
                height: headlen,
                width: headlen,
                fill: currentColor,
                angle: (angle * 180 / Math.PI) + 90,
            });
            
            // Correctly position the arrowhead at the end of the line
            const endPoint = new fabric.Point(toX, toY);
            const startPoint = new fabric.Point(fromX, fromY);
            const angleRad = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
            const length = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2));

            const newEndPointX = startPoint.x + (length - (headlen / 2)) * Math.cos(angleRad);
            const newEndPointY = startPoint.y + (length - (headlen / 2)) * Math.sin(angleRad);
            
            arrowhead.set({
                left: newEndPointX + (headlen / 2) * Math.cos(angleRad),
                top: newEndPointY + (headlen / 2) * Math.sin(angleRad),
            });


            return new fabric.Group([line, arrowhead], {
                originX: 'center',
                originY: 'center'
            });
        }

        clearBtn.addEventListener('click', () => {
            if (canvas) {
                canvas.clear();
            }
        });

        // Initialize Split.js
        Split(['#whiteboard-area', '#chat-area'], {
            sizes: [75, 25],
            minSize: [400, 250],
            gutterSize: 10,
            cursor: 'col-resize',
            onDrag: resizeCanvas,
        });

        // Initialize the whiteboard on load
        initializeWhiteboard();
    </script>
</body>
</html>
